package org.molgenis.data.csv.services;

import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import org.apache.commons.io.input.BOMInputStream;
import org.molgenis.data.MolgenisDataException;
import org.molgenis.data.csv.utils.CsvFileExtensions;
import org.molgenis.data.csv.utils.CsvValidation;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.io.*;
import java.util.List;

import static com.google.common.collect.Sets.newHashSet;
import static java.lang.String.format;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.molgenis.util.FileExtensionUtils.findExtensionFromPossibilities;
import static org.molgenis.util.file.ZipFileUtil.unzip;

@Component
public class CsvServiceImpl implements CsvService
{

	private Character separator = DEFAULT_CSV_SEPARATOR;

	@Override
	public List<String[]> buildLinesFromFile(File file)
	{
		List<String[]> lines = null;
		String fileExtension = StringUtils.getFilenameExtension(file.getName());
		if (fileExtension.equalsIgnoreCase(CsvFileExtensions.ZIP.toString()))
		{
			try
			{
				List<File> filesInZip = unzip(file);
				for (File fileInZip : filesInZip)
				{
					String fileInZipExtension = findExtensionFromPossibilities(fileInZip.getName(),
							newHashSet(CsvFileExtensions.CSV.toString()));
					if (fileInZipExtension != null)
					{
						lines = createCsvReaderAndReturnLines(fileInZip, fileExtension);
					}
				}
			}
			catch (IOException err)
			{
				throw new MolgenisDataException(format("CSV-file [%s] is corrupt", file.getName()));
			}
		}
		else
		{
			lines = createCsvReaderAndReturnLines(file, fileExtension);
		}
		return lines;
	}

	@Override
	public List<String[]> buildLinesFromFile(File file, Character separator)
	{
		if (separator == null)
		{
			this.separator = DEFAULT_CSV_SEPARATOR;
		}
		else
		{
			this.separator = separator;
		}

		return buildLinesFromFile(file);
	}

	/**
	 * <p>Create a CsvReader to obtain data from CSV file</p>
	 *
	 * @param file given file
	 * @return inesList of rows
	 */
	private List<String[]> createCsvReaderAndReturnLines(File file, String fileExtension)
	{
		List<String[]> lines;
		CSVReader reader;
		try (InputStream inputStream = new FileInputStream(file))
		{
			reader = createCsvReader(fileExtension, removeByteOrderMark(inputStream));
			if (reader != null)
			{
				lines = reader.readAll();
				CsvValidation.validateCsvFile(lines, file.getName());
			}
			else
			{
				throw new MolgenisDataException(format("CSV-file [%s] is corrupt", file.getName()));
			}
		}
		catch (IOException err)
		{
			throw new MolgenisDataException(format("CSV-file [%s] is corrupt", file.getName()));
		}
		return lines;
	}

	/**
	 * <p>Convert the inputstreams that can be generated by the CsvIterator and check on BOM-attachements.</p>
	 *
	 * @param inputStream from zipfile or normal files
	 * @return inputStream without ByteOrderMark (always)
	 */

	private InputStream removeByteOrderMark(InputStream inputStream)
	{
		return new BOMInputStream(inputStream, false);
	}

	private CSVReader createCsvReader(String fileExtension, InputStream in)
	{
		CSVReader csvReader = null;
		Reader reader = new InputStreamReader(in, UTF_8);
		if (CsvValidation.validateCsvFileExtensions(fileExtension))
		{
			if (fileExtension.equals(CsvFileExtensions.TSV.toString()))
			{
				if (separator == DEFAULT_CSV_SEPARATOR)
				{
					separator = '\t';
				}
			}
			CSVParser parser = new CSVParserBuilder().withSeparator(separator).build();
			csvReader = new CSVReaderBuilder(reader).withCSVParser(parser).build();
		}
		return csvReader;
	}

}