package org.molgenis.data.csv.service;

import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import org.apache.commons.io.input.BOMInputStream;
import org.molgenis.data.MolgenisDataException;
import org.molgenis.data.csv.utils.CsvFileExtensions;
import org.molgenis.data.csv.utils.CsvValidation;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.io.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.String.format;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.molgenis.data.csv.CsvRepositoryCollection.MAC_ZIP;
import static org.molgenis.util.FileExtensionUtils.getFileNameWithoutExtension;
import static org.molgenis.util.file.ZipFileUtil.unzip;

@Component
public class CsvServiceImpl implements CsvService
{

	private Character separator = DEFAULT_CSV_SEPARATOR;
	
	@Override
	public Map<String, List<String[]>> buildLinesFromFile(File file)
	{
		return parseCsvOrZipFile(file, null);
	}

	@Override
	public Map<String, List<String[]>> buildLinesFromFile(File file, String repositoryName)
	{
		return parseCsvOrZipFile(file, repositoryName);
	}

	@Override
	public Map<String, List<String[]>> buildLinesFromFile(File file, String repositoryName, Character separator)
	{
		if (separator == null)
		{
			this.separator = DEFAULT_CSV_SEPARATOR;
		}
		else
		{
			this.separator = separator;
		}
		return buildLinesFromFile(file, repositoryName);
	}

	private Map<String, List<String[]>> parseCsvOrZipFile(File file, String repositoryName)
	{
		Map<String, List<String[]>> keyValueCsvLines = new HashMap<>();
		String fileExtension = StringUtils.getFilenameExtension(file.getName());
		if (fileExtension.contains(CsvFileExtensions.ZIP.toString()))
		{
			try
			{
				for (File zipEntry : unzip(file))
				{
					String zipFileExtension = StringUtils.getFilenameExtension(zipEntry.getName());
					{
						if (!zipEntry.getName().contains(MAC_ZIP) && !zipEntry.isDirectory())
						{
							if (repositoryName != null && repositoryName.equals(zipEntry.getName()))
							{
								List<String[]> lines = parseCsvContent(zipEntry, zipFileExtension);
								keyValueCsvLines.put(createValidIdFromFileName(zipEntry.getName()), lines);
								break;
							}
							else
							{
								List<String[]> lines = parseCsvContent(zipEntry, zipFileExtension);
								keyValueCsvLines.put(createValidIdFromFileName(zipEntry.getName()), lines);
							}
						}
					}
				}
			}
			catch (IOException e)
			{
				throw new MolgenisDataException(format("No file found [%s]", file.getName()));
			}
		}
		else
		{
			keyValueCsvLines.put(createValidIdFromFileName(file.getName()), parseCsvContent(file, fileExtension));
		}
		return keyValueCsvLines;
	}

	/**
	 * <p>Create a CsvReader to obtain data from CSV file</p>
	 *
	 * @param file given file
	 * @return inesList of rows
	 */
	private List<String[]> parseCsvContent(File file, String fileExtension)
	{
		List<String[]> lines;
		CSVReader reader;
		try (InputStream inputStream = new FileInputStream(file))
		{
			reader = parseCsvContent(fileExtension, removeByteOrderMark(inputStream));
			if (reader != null)
			{
				lines = reader.readAll();
				CsvValidation.validateCsvFile(lines, file.getName());
			}
			else
			{
				throw new MolgenisDataException(format("CSV-file [%s] is corrupt", file.getName()));
			}
		}
		catch (IOException err)
		{
			throw new MolgenisDataException(format("CSV-file [%s] is corrupt", file.getName()));
		}
		return lines;
	}

	/**
	 * <p>Convert the inputstreams that can be generated by the CsvIterator and check on BOM-attachements.</p>
	 *
	 * @param inputStream from zipfile or normal files
	 * @return inputStream without ByteOrderMark (always)
	 */
	private InputStream removeByteOrderMark(InputStream inputStream)
	{
		return new BOMInputStream(inputStream, false);
	}

	private CSVReader parseCsvContent(String fileExtension, InputStream in)
	{
		CSVReader csvReader = null;
		Reader reader = new InputStreamReader(in, UTF_8);
		if (CsvValidation.validateCsvFileExtensions(fileExtension))
		{
			if (fileExtension.equals(CsvFileExtensions.TSV.toString()))
			{
				if (separator == DEFAULT_CSV_SEPARATOR)
				{
					separator = '\t';
				}
			}
			CSVParser parser = new CSVParserBuilder().withSeparator(separator).build();
			csvReader = new CSVReaderBuilder(reader).withCSVParser(parser).build();
		}
		return csvReader;
	}

	@Override
	public String createValidIdFromFileName(String filename)
	{
		String packageName = getFileNameWithoutExtension(filename);
		return packageName.replaceAll(ILLEGAL_CHARACTER_REGEX, "_");
	}

}